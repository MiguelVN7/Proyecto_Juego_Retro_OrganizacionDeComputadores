// Paddle.jack
// Representa la paleta controlada por el jugador
// Maneja movimiento horizontal y detección de colisiones

class Paddle {
    // Posición de la paleta
    field int x;
    field int y;
    
    // Dimensiones de la paleta
    field int width;
    field int height;
    
    // Velocidad de movimiento
    field int speed;
    
    // Límites de la pantalla
    field int minX;
    field int maxX;
    
    /** Constructor - Crea una nueva paleta */
    constructor Paddle new(int Ax, int Ay, int Awidth, int Aheight) {
        let x = Ax;
        let y = Ay;
        let width = Awidth;
        let height = Aheight;
        let speed = 5;  // Píxeles por movimiento
        
        // Configurar límites (la paleta no puede salir de la pantalla)
        let minX = 0;
        let maxX = 512 - width;  // 512 es el ancho de la pantalla
        
        return this;
    }
    
    /** Dibujar la paleta en su posición actual */
    method void draw() {
        do Screen.setColor(true);  // Color blanco (sólido)
        do Screen.drawRectangle(x, y, x + width, y + height);
        return;
    }
    
    /** Borrar la paleta (útil antes de moverla) */
    method void erase() {
        do Screen.setColor(false);  // Color negro (fondo)
        do Screen.drawRectangle(x, y, x + width, y + height);
        return;
    }
    
    /** Mover paleta a la izquierda */
    method void moveLeft() {
        var int oldX;
        
        let oldX = x;
        
        // Calcular nueva posición
        if (x > (minX + speed)) {
            let x = x - speed;
        } else {
            let x = minX;  // No pasar el límite izquierdo
        }
        
        // Solo redibujar si la posición realmente cambió
        if (~(x = oldX)) {
            // Borrar TODA la posición anterior
            do Screen.setColor(false);
            do Screen.drawRectangle(oldX, y, oldX + width, y + height);
            
            // Dibujar en nueva posición
            do Screen.setColor(true);
            do Screen.drawRectangle(x, y, x + width, y + height);
        }
        
        return;
    }
    
    /** Mover paleta a la derecha */
    method void moveRight() {
        var int oldX;
        
        let oldX = x;
        
        // Calcular nueva posición
        if (x < (maxX - speed)) {
            let x = x + speed;
        } else {
            let x = maxX;  // No pasar el límite derecho
        }
        
        // Solo redibujar si la posición realmente cambió
        if (~(x = oldX)) {
            // Borrar TODA la posición anterior
            do Screen.setColor(false);
            do Screen.drawRectangle(oldX, y, oldX + width, y + height);
            
            // Dibujar en nueva posición
            do Screen.setColor(true);
            do Screen.drawRectangle(x, y, x + width, y + height);
        }
        
        return;
    }
    
    /** Obtener posición X de la paleta */
    method int getX() {
        return x;
    }
    
    /** Obtener posición Y de la paleta */
    method int getY() {
        return y;
    }
    
    /** Obtener ancho de la paleta */
    method int getWidth() {
        return width;
    }
    
    /** Obtener alto de la paleta */
    method int getHeight() {
        return height;
    }
    
    /** Obtener el centro X de la paleta (útil para física de rebote) */
    method int getCenterX() {
        return x + (width / 2);
    }
    
    /** Verificar si un punto está dentro de la paleta */
    method boolean contains(int px, int py) {
        if ((px > x) & (px < (x + width))) {
            if ((py > y) & (py < (y + height))) {
                return true;
            }
        }
        return false;
    }
    
    /** Reiniciar posición de la paleta */
    method void reset(int newX, int newY) {
        // Borrar posición actual
        do erase();
        
        // Establecer nueva posición
        let x = newX;
        let y = newY;
        
        // Dibujar en nueva posición
        do draw();
        
        return;
    }
    
    /** Liberar memoria */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}
