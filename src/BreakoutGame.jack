// BreakoutGame.jack
// Clase principal del juego que maneja la lógica general
// Controla el estado del juego, puntuación, vidas y niveles
// OPTIMIZADO: Loop determinista con frame limiter y dirty-rectangle rendering

class BreakoutGame {
    // Componentes del juego
    field Paddle paddle;
    field Ball ball;
    field BlockGrid blockGrid;
    
    // Estado del juego
    field int score;
    field int lives;
    field int level;
    field boolean gameOver;
    field boolean victory;
    field boolean paused;
    field boolean running;
    
    // Constantes
    field int screenWidth;
    field int screenHeight;
    field int MAX_LEVELS;
    
    // ========== PARAMETROS TUNEABLES ==========
    field int FRAME_WAIT_MS;     // Milisegundos de espera por frame
    field boolean DEBUG;         // true para mostrar contadores en pantalla
    
    // Contadores de timing
    field int frame;             // Contador global de frames
    
    // Estados del juego (máquina de estados)
    field int state;             // 0=MENU, 1=PLAYING, 2=LOST_LIFE, 3=GAME_OVER, 4=VICTORY, 5=LEVEL_COMPLETE
    field boolean victoryShown;  // Flag para mostrar victoria solo una vez
    field boolean gameOverShown; // Flag para mostrar game over solo una vez
    field boolean levelCompleteShown; // Flag para nivel completado
    // =========================================
    
    // Cache para HUD (evitar redibujado innecesario)
    field int lastDrawnScore;
    field int lastDrawnLives;
    field int lastDrawnLevel;
    
    /** Constructor - Inicializa el juego */
    constructor BreakoutGame new() {
        // Configurar dimensiones de pantalla
        let screenWidth = 512;
        let screenHeight = 256;
        let MAX_LEVELS = 2;
        
        // ========== CONFIGURAR PARAMETROS TUNABLES ==========
        // FRAME_WAIT_MS aumentado para evitar busy-loop y normalizar velocidad.
        // 10-15ms es un buen balance (60-100 FPS aprox).
        let FRAME_WAIT_MS = 15;     
        let DEBUG = false;          
        // ====================================================
        
        // Inicializar contadores
        let frame = 0;
        let state = 0;              // Empezar en MENU
        let victoryShown = false;   // No mostrado aún
        let gameOverShown = false;  // No mostrado aún
        let levelCompleteShown = false;
        
        // Inicializar cache de HUD (para evitar redibujado innecesario)
        let lastDrawnScore = -1;
        let lastDrawnLives = -1;
        let lastDrawnLevel = -1;
        
        // Inicializar estado del juego
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameOver = false;
        let victory = false;
        let paused = false;
        let running = true;
        
        // Crear componentes del juego
        let paddle = Paddle.new(226, 230, 60, 8);  // Centro inferior
        let ball = Ball.new(256, 200, 4);           // Centro arriba de la paleta
        let blockGrid = BlockGrid.new(5, 10);       // 5 filas, 10 columnas
        
        return this;
    }
    
    /** Loop principal del juego - OPTIMIZADO para timing determinista */
    method void run() {
        var char key;
        
        // Mostrar pantalla de inicio y esperar input
        do Screen.clearScreen();
        do GameUI.showStartScreen();
        
        // Loop principal del juego - MAQUINA DE ESTADOS DETERMINISTA
        while (running) {
            
            // ===== STATE 0: MENU =====
            if (state = 0) {
                let key = Keyboard.keyPressed();
                if (key = 32) {  // Espacio presionado
                    do resetGame();           // Reiniciar juego completo
                    do initialDraw();         // Dibujar todo (una sola vez)
                    let state = 1;            // Transición a PLAYING
                    do waitForKeyRelease();   // Evitar input repetido
                }
                if (key = 81) {  // Q para salir desde menú
                    let running = false;
                }
            }
            
            // ===== STATE 1: PLAYING =====
            if (state = 1) {
                let key = Keyboard.keyPressed();
                
                // Procesar input del jugador (Mueve la paleta)
                do processInput(key);
                
                // UPDATE de física CADA FRAME (Sincronizado con input)
                do updatePhysics();
                
                // RENDER parcial: solo borra y redibuja lo que cambió
                do renderFrame();
                
                // DEBUG: Mostrar contadores si está activado
                if (DEBUG) {
                    do showDebugInfo();
                }
                
                // Verificar condiciones de transición
                if (ball.getY() > screenHeight) {
                    let state = 2;            // Transición a LOST_LIFE
                }
                if (blockGrid.allBlocksDestroyed()) {
                    if (level < MAX_LEVELS) {
                        let levelCompleteShown = false;
                        let state = 5;        // Transición a LEVEL_COMPLETE
                    } else {
                        let victoryShown = false; 
                        let state = 4;        // Transición a VICTORY
                    }
                }
            }
            
            // ===== STATE 2: LOST_LIFE =====
            if (state = 2) {
                do loseLifeTransition();      // Maneja pérdida de vida
                let state = 1;                // Volver a PLAYING (o a GAME_OVER si lives=0)
                if (gameOver) {
                    let gameOverShown = false; // Reset flag antes de transición
                    let state = 3;
                }
            }
            
            // ===== STATE 3: GAME_OVER =====
            if (state = 3) {
                // ✅ Solo mostrar game over en el primer frame de este estado
                if (~gameOverShown) {
                    do GameUI.showGameOver(score);
                    let gameOverShown = true;
                }
                
                let key = Keyboard.keyPressed();
                if (key = 81) {  // Q para VOLVER AL MENU
                    do Screen.clearScreen();
                    do GameUI.showStartScreen();
                    let state = 0;
                    do waitForKeyRelease();
                }
                // Opcionalmente: Enter (128) para reiniciar
                if (key = 128) {  // Enter
                    do resetGame();
                    do initialDraw(); // Necesario porque vamos a PLAYING directo
                    let state = 1;    // Volver a PLAYING
                    do waitForKeyRelease();
                }
            }
            
            // ===== STATE 4: VICTORY =====
            if (state = 4) {
                // ✅ Solo mostrar victoria en el primer frame de este estado
                if (~victoryShown) {
                    do GameUI.showVictory(score);
                    let victoryShown = true;
                }
                
                let key = Keyboard.keyPressed();
                if (key = 81) {  // Q para VOLVER AL MENU
                    do Screen.clearScreen();
                    do GameUI.showStartScreen();
                    let state = 0;
                    do waitForKeyRelease();
                }
                if (key = 128) {  // Enter para reiniciar
                    do resetGame();
                    do initialDraw();
                    let state = 1;
                    do waitForKeyRelease();
                }
            }
            
            // ===== STATE 5: LEVEL_COMPLETE =====
            if (state = 5) {
                if (~levelCompleteShown) {
                    do GameUI.showLevelComplete(score, level + 1);
                    let levelCompleteShown = true;
                }
                
                let key = Keyboard.keyPressed();
                if (key = 32) { // ESPACIO para Siguiente Nivel
                    do startNextLevel();
                    do initialDraw();
                    let state = 1; // PLAYING
                    do waitForKeyRelease();
                }
                if (key = 81) { // Q para VOLVER AL MENU
                    do Screen.clearScreen();
                    do GameUI.showStartScreen();
                    let state = 0;
                    do waitForKeyRelease();
                }
            }
            
            // Incrementar contador de frames
            let frame = frame + 1;
            
            // FRAME LIMITER: Wait crucial para mantener velocidad constante
            do Sys.wait(FRAME_WAIT_MS);
        }
        
        return;
    }
    
    /** Procesar entrada del usuario (solo movimiento y pausa) */
    method void processInput(char key) {
        // Flecha izquierda (130)
        if (key = 130) {
            do paddle.moveLeft();
        }
        
        // Flecha derecha (132)
        if (key = 132) {
            do paddle.moveRight();
        }
        
        // Espacio (32) - Pausar/Despausar
        if (key = 32) {
            let paused = ~paused;
            if (paused) {
                do GameUI.showPauseScreen();
            } else {
                do GameUI.hidePauseScreen();
                // Redibujar la bola por si estaba detrás del menú
                do ball.draw();
            }
            do waitForKeyRelease();
        }
        
        // Q (81) - Salir del juego (durante el juego va a Game Over o Menu?)
        // Estandar Breakout: Q en juego sale al menu o cierra.
        // Vamos a hacer que salga del juego (running=false) como antes para consistencia
        // o al menu. "Salir del juego" suele ser Quit App.
        if (key = 81) {
            let running = false;
        }
        
        return;
    }
    
    /** Actualizar física del juego (movimiento y colisiones) */
    method void updatePhysics() {
        var int earnedPoints;
        
        // No actualizar si está pausado
        if (paused) {
            return;
        }
        
        // Mover la pelota
        do ball.move();
        
        // Verificar colisiones con paredes
        do checkWallCollisions();
        
        // Verificar colisión con la paleta
        do checkPaddleCollision();
        
        // Verificar colisión con bloques y actualizar score
        let earnedPoints = blockGrid.checkCollision(ball);
        if (earnedPoints > 0) {
            let score = score + earnedPoints;
        }
        
        return;
    }
    
    /** Renderizar frame actual (OPTIMIZADO: solo dibuja cambios) */
    method void renderFrame() {
        // La bola y el paddle ya se borran/redibujan en sus métodos move()
        // Solo redibujar el HUD si cambió (OPTIMIZACIÓN CRÍTICA)
        do drawHUDIfChanged();
        
        return;
    }
    
    /** Dibujar HUD solo si los valores cambiaron (OPTIMIZACIÓN ANTI-MEMORY-LEAK) */
    method void drawHUDIfChanged() {
        // Solo redibujar score si cambió
        if (~(score = lastDrawnScore)) {
            do GameUI.drawScore(score);
            let lastDrawnScore = score;
        }
        
        // Solo redibujar lives si cambió
        if (~(lives = lastDrawnLives)) {
            do GameUI.drawLives(lives);
            let lastDrawnLives = lives;
        }
        
        // Solo redibujar level si cambió
        if (~(level = lastDrawnLevel)) {
            do GameUI.drawLevel(level);
            let lastDrawnLevel = level;
        }
        
        return;
    }
    
    /** Dibujo inicial completo (solo se llama una vez al iniciar nivel) */
    method void initialDraw() {
        do Screen.clearScreen();      // Limpiar pantalla (solo una vez)
        
        do GameUI.drawHUDLabels();    // Dibujar etiquetas estáticas una vez
        
        // Resetear cache para asegurar dibujo
        let lastDrawnScore = -1; 
        let lastDrawnLives = -1;
        let lastDrawnLevel = -1;
        do drawHUDIfChanged();        // Forzar dibujo de valores
        
        do blockGrid.draw();          // Dibujar bloques
        do paddle.draw();             // Dibujar paleta
        do ball.draw();               // Dibujar bola
        
        return;
    }
    
    /** Verificar colisiones con paredes */
    method void checkWallCollisions() {
        var int ballX, ballY, ballRadius, ballVelY;
        
        let ballX = ball.getX();
        let ballY = ball.getY();
        let ballRadius = ball.getRadius();
        let ballVelY = ball.getVelocityY();
        
        // Pared izquierda
        if (ballX < ballRadius) {
            do ball.bounceHorizontal();
            // ✅ Separar de la pared
            do ball.setX(ballRadius + 1);
        }
        
        // Pared derecha
        if (ballX > (screenWidth - ballRadius)) {
            do ball.bounceHorizontal();
            // ✅ Separar de la pared
            do ball.setX(screenWidth - ballRadius - 1);
        }
        
        // Pared superior - CRÍTICO: Detectar cuando va HACIA arriba
        if ((ballY < (ballRadius + 20)) & (ballVelY < 0)) {
            do ball.bounceVertical();
            // ✅ Separar del techo con margen extra
            do ball.setY(ballRadius + 22);
        }
        
        return;
    }
    
    /** Verificar colisión con la paleta */
    method void checkPaddleCollision() {
        var int ballY, paddleY, ballRadius;
        
        if (CollisionDetector.checkBallPaddle(ball, paddle)) {
            // Rebotar la bola
            do ball.bounceVertical();
            
            // CRÍTICO: Corrección precisa de posición
            let ballY = ball.getY();
            let paddleY = paddle.getY();
            let ballRadius = ball.getRadius();
            
            // Colocar la bola EXACTAMENTE encima de la paleta
            if ((ballY + ballRadius) > paddleY) {
                do ball.setY(paddleY - ballRadius - 2); 
            }
        }
        return;
    }
    
    /** Transición de pérdida de vida (estado LOST_LIFE) */
    method void loseLifeTransition() {
        let lives = lives - 1;
        
        if (lives > 0) {
            // Borrar bola y paddle de posiciones actuales
            do ball.erase();
            do paddle.erase();
            
            // Reiniciar posiciones
            do ball.reset(256, 200);
            do paddle.reset(226, 230);
            
            // Redibujar
            do ball.draw();
            do paddle.draw();
            
            // WAIT CRITICO: pausa para evitar bucle apretado
            do Sys.wait(1000); // 1 segundo de espera
        } else {
            // Game Over
            let gameOver = true;
            do Screen.clearScreen();  // Limpiar antes de mostrar game over
        }
        
        return;
    }
    
    /** Reiniciar nivel actual */
    method void resetLevel() {
        // Reiniciar bola y paddle
        do ball.reset(256, 200);
        do paddle.reset(226, 230);
        
        // Configurar bloques para el nivel actual
        do blockGrid.reset(level);
        
        // Resetear flags
        let paused = false;
        
        return;
    }

    /** Iniciar siguiente nivel */
    method void startNextLevel() {
        let level = level + 1;
        
        // Aumentar velocidad si es nivel 2
        if (level = 2) {
            do ball.increaseSpeed();
        }
        
        do resetLevel();
        return;
    }
    
    /** Reiniciar juego completo */
    method void resetGame() {
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameOver = false;
        let victory = false;
        let paused = false;
        let frame = 0;
        
        // Resetear velocidad de la bola (crear nueva o resetear speed)
        // Como Ball no tiene resetSpeed(), asumimos que reset() la pone default
        // Pero reset() solo pone velocidad base. Si increaseSpeed modificó velocityX/Y,
        // reset() las vuelve a poner en 'speed'. 'speed' es campo de Ball.
        // Deberíamos asegurarnos que Ball vuelva a estado base.
        // En Ball.jack: reset() usa 'speed'. 'speed' es inicializado en constructor.
        // increaseSpeed aumenta velocityX/Y pero no 'speed'.
        // Asi que reset() en Ball resetea la velocidad. Perfecto.
        
        do resetLevel();
        
        return;
    }
    
    /** Esperar a que se suelte cualquier tecla (NO bloqueante con wait) */
    method void waitForKeyRelease() {
        var char key;
        
        let key = Keyboard.keyPressed();
        while (~(key = 0)) {
            let key = Keyboard.keyPressed();
            do Sys.wait(10);  // Pequeño wait para evitar busy-loop
        }
        
        return;
    }
    
    /** Mostrar información de depuración (DEBUG mode) */
    method void showDebugInfo() {
        // Mostrar en esquina superior derecha
        do Output.moveCursor(0, 50);
        do Output.printString("F:");
        do Output.printInt(frame);
        return;
    }
    
    /** Liberar memoria */
    method void dispose() {
        do paddle.dispose();
        do ball.dispose();
        do blockGrid.dispose();
        do Memory.deAlloc(this);
        return;
    }
}