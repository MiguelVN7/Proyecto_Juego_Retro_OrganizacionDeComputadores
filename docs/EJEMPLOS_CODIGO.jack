// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EJEMPLO DE CÃ“DIGO CLAVE - BreakoutGame.jack OPTIMIZADO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. DECLARACIÃ“N DE CAMPOS PARA TIMING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class BreakoutGame {
    // ... otros campos ...
    
    // CAMPOS DE TIMING (NUEVOS)
    field int UPDATE_EVERY;      // Actualizar fÃ­sica cada N frames
    field int FRAME_WAIT_MS;     // Milisegundos de espera por frame
    field boolean DEBUG;         // Modo debug
    field int frame;             // Contador de frames
    field int tick;              // Contador de updates de fÃ­sica
    field int state;             // Estado del juego (0-4)
    
    // ...
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2. CONFIGURACIÃ“N EN EL CONSTRUCTOR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

constructor BreakoutGame new() {
    // ... inicializaciÃ³n normal ...
    
    // ========== PARAMETROS TUNABLES ==========
    let UPDATE_EVERY = 3;       // FÃ­sica cada 3 frames
    let FRAME_WAIT_MS = 2;      // 2ms de wait por frame
    let DEBUG = false;          // Cambiar a true para debug
    // =========================================
    
    let frame = 0;
    let tick = 0;
    let state = 0;              // Empezar en MENU
    
    // ... crear objetos del juego ...
    
    return this;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3. LOOP PRINCIPAL OPTIMIZADO
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

method void run() {
    var char key;
    
    // Mostrar menÃº inicial
    do Screen.clearScreen();
    do GameUI.showStartScreen();
    
    // LOOP PRINCIPAL - MÃQUINA DE ESTADOS
    while (running) {
        
        // ===== STATE 0: MENU =====
        if (state = 0) {
            let key = Keyboard.keyPressed();
            if (key = 32) {  // Space
                do resetLevel();
                do initialDraw();       // Dibujar TODO una sola vez
                let state = 1;          // â†’ PLAYING
                do waitForKeyRelease();
            }
        }
        
        // ===== STATE 1: PLAYING =====
        if (state = 1) {
            let key = Keyboard.keyPressed();
            do processInput(key);
            
            // UPDATE de fÃ­sica solo cada UPDATE_EVERY frames
            // Esto normaliza la velocidad independiente del slider
            if ((frame / UPDATE_EVERY) * UPDATE_EVERY = frame) {
                do updatePhysics();     // Mover bola, colisiones
                let tick = tick + 1;
            }
            
            // RENDER parcial (solo HUD, bola/paddle se autodibujan)
            do renderFrame();
            
            // DEBUG: Mostrar contadores
            if (DEBUG) {
                do showDebugInfo();
            }
            
            // Verificar transiciones
            if (ball.getY() > screenHeight) {
                let state = 2;          // â†’ LOST_LIFE
            }
            if (blockGrid.allBlocksDestroyed()) {
                let state = 4;          // â†’ VICTORY
            }
        }
        
        // ===== STATE 2: LOST_LIFE =====
        if (state = 2) {
            do loseLifeTransition();    // Maneja pÃ©rdida con wait
            let state = 1;              // â†’ PLAYING (o GAME_OVER si lives=0)
            if (gameOver) {
                let state = 3;
            }
        }
        
        // ===== STATE 3: GAME_OVER =====
        if (state = 3) {
            do GameUI.showGameOver(score);
            let key = Keyboard.keyPressed();
            if (key = 81) {             // Q para salir
                let running = false;
            }
            if (key = 128) {            // Enter para reiniciar
                do resetGame();
                do Screen.clearScreen();
                do GameUI.showStartScreen();
                let state = 0;          // â†’ MENU
            }
        }
        
        // ===== STATE 4: VICTORY =====
        if (state = 4) {
            do GameUI.showVictory(score);
            // ... similar a GAME_OVER ...
        }
        
        // Incrementar frame
        let frame = frame + 1;
        
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘ FRAME LIMITER - LA CLAVE DEL TIMING DETERMINISTA â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Este Sys.wait() hace que el juego sea independiente
        // del CPU slider. Sin esto, el juego va a velocidad
        // del emulador (miles de FPS en rÃ¡pido).
        do Sys.wait(FRAME_WAIT_MS);
    }
    
    return;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4. UPDATE DE FÃSICA (SEPARADO DEL RENDER)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

method void updatePhysics() {
    // No actualizar si estÃ¡ pausado
    if (paused) {
        return;
    }
    
    // Mover la bola (ella misma hace erase() y draw())
    do ball.move();
    
    // Verificar colisiones
    do checkWallCollisions();
    do checkPaddleCollision();
    do blockGrid.checkCollision(ball);
    
    return;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5. RENDER PARCIAL (DIRTY RECTANGLES)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

method void renderFrame() {
    // NO llamamos Screen.clearScreen() aquÃ­
    // La bola y el paddle ya se borran/redibujan en sus mÃ©todos move()
    // Solo necesitamos redibujar el HUD (muy barato)
    
    do drawHUD();
    
    return;
}

method void drawHUD() {
    do GameUI.drawScore(score);
    do GameUI.drawLives(lives);
    do GameUI.drawLevel(level);
    return;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 6. DIBUJO INICIAL COMPLETO (SOLO UNA VEZ POR NIVEL)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

method void initialDraw() {
    // Esta es la ÃšNICA vez que limpiamos la pantalla completa
    do Screen.clearScreen();
    
    // Dibujar todos los elementos
    do blockGrid.draw();
    do paddle.draw();
    do ball.draw();
    do drawHUD();
    
    return;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 7. TRANSICIÃ“N DE PÃ‰RDIDA DE VIDA (CON WAIT APROPIADO)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

method void loseLifeTransition() {
    let lives = lives - 1;
    
    if (lives > 0) {
        // Borrar posiciones actuales
        do ball.erase();
        do paddle.erase();
        
        // Reiniciar posiciones
        do ball.reset(256, 200);
        do paddle.reset(226, 230);
        
        // Redibujar
        do ball.draw();
        do paddle.draw();
        
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘ WAIT CRÃTICO: Evita bucle apretado              â•‘
        // â•‘ Sin esto, el juego reinicia instantÃ¡neamente    â•‘
        // â•‘ y puede causar miles de transiciones/segundo    â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        do Sys.wait(400);
    } else {
        // Game Over
        let gameOver = true;
        do Screen.clearScreen();
    }
    
    return;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 8. WAIT FOR KEY RELEASE (NO BLOQUEANTE)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

method void waitForKeyRelease() {
    var char key;
    
    let key = Keyboard.keyPressed();
    while (~(key = 0)) {
        let key = Keyboard.keyPressed();
        
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘ PequeÃ±o wait para evitar busy-loop              â•‘
        // â•‘ ANTES: loop apretado sin wait (malo)            â•‘
        // â•‘ DESPUÃ‰S: loop con wait (bueno)                  â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        do Sys.wait(10);
    }
    
    return;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 9. DEBUG INFO (MODO INSTRUMENTACIÃ“N)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

method void showDebugInfo() {
    // Mostrar en esquina superior derecha
    do Output.moveCursor(0, 50);
    do Output.printString("F:");
    do Output.printInt(frame);
    
    do Output.moveCursor(1, 50);
    do Output.printString("T:");
    do Output.printInt(tick);
    
    // Verificar que tick = frame / UPDATE_EVERY
    // Ejemplo: frame=120, UPDATE_EVERY=3 â†’ tick deberÃ­a ser 40
    
    return;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CÃLCULO DE FÃSICA NORMALIZADA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
   La condiciÃ³n clave es:

       if ((frame / UPDATE_EVERY) * UPDATE_EVERY = frame)

   Â¿QuÃ© hace?
   - Verifica si frame es divisible por UPDATE_EVERY
   - Solo entonces se ejecuta updatePhysics()

   Ejemplo con UPDATE_EVERY = 3:

   Frame  | frame/3 | (frame/3)*3 | Â¿Igual? | Update?
   -------|---------|-------------|---------|--------
     0    |    0    |      0      |   âœ“     |  âœ“
     1    |    0    |      0      |   âœ—     |  âœ—
     2    |    0    |      0      |   âœ—     |  âœ—
     3    |    1    |      3      |   âœ“     |  âœ“
     4    |    1    |      3      |   âœ—     |  âœ—
     5    |    1    |      3      |   âœ—     |  âœ—
     6    |    2    |      6      |   âœ“     |  âœ“
     ...

   Resultado: La fÃ­sica se actualiza cada 3 frames (frames 0, 3, 6, 9...)

   Con FRAME_WAIT_MS = 2:
   - Cada frame dura ~2ms
   - FÃ­sica se actualiza cada 6ms (3 frames Ã— 2ms)
   - Tasa de actualizaciÃ³n: ~166 Hz de render, ~55 Hz de fÃ­sica

   Esto es INDEPENDIENTE del CPU slider porque Sys.wait() es real.
*/


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EJEMPLO DE Ball.move() CON DIRTY RECTANGLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// En Ball.jack:

method void move() {
    // 1. BORRAR posiciÃ³n actual (dirty rectangle)
    do erase();
    
    // 2. ACTUALIZAR posiciÃ³n
    let x = x + velocityX;
    let y = y + velocityY;
    
    // 3. DIBUJAR en nueva posiciÃ³n
    do draw();
    
    return;
}

method void erase() {
    do Screen.setColor(false);      // Negro (fondo)
    do Screen.drawCircle(x, y, radius);
    return;
}

method void draw() {
    do Screen.setColor(true);       // Blanco (sÃ³lido)
    do Screen.drawCircle(x, y, radius);
    return;
}

/*
   Este patrÃ³n (erase â†’ actualizar â†’ draw) es CLAVE:
   - Solo se borran los pÃ­xeles de la bola (pequeÃ±a Ã¡rea)
   - NO se borra toda la pantalla
   - Elimina parpadeo y mejora performance dramÃ¡ticamente
*/


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANTES vs DESPUÃ‰S - COMPARACIÃ“N DE CÃ“DIGO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                              ANTES (MALO)                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

method void run() {
    do GameUI.showStartScreen();
    do waitForSpaceKey();           // âŒ Busy-wait sin Sys.wait
    
    while (running) {
        let key = Keyboard.keyPressed();
        do processInput(key);
        
        if ((~paused) & (~gameOver) & (~victory)) {
            do update();            // âŒ Se ejecuta SIEMPRE
        }
        
        // âŒ BUSY-LOOP CRÃTICO
        let delay = 0;
        while (delay < 50) {
            let delay = delay + 1;  // Miles de iteraciones por segundo
        }
    }
    return;
}

method void update() {
    do ball.move();                 // âŒ Velocidad acoplada al slider
    do checkWallCollisions();
    do checkPaddleCollision();
    do blockGrid.checkCollision(ball);
    
    if (ball.getY() > screenHeight) {
        do loseLife();              // âŒ Puede causar bucle apretado
    }
    
    do draw();                      // âŒ Llama clearScreen() cada vez
    return;
}

method void draw() {
    do Screen.clearScreen();        // âŒ Borra TODA la pantalla cada frame
    do blockGrid.draw();
    do paddle.draw();
    do ball.draw();
    do GameUI.drawScore(score);
    // ...
    return;
}


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                            DESPUÃ‰S (BUENO)                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

method void run() {
    do Screen.clearScreen();
    do GameUI.showStartScreen();
    
    while (running) {
        // MÃ¡quina de estados clara
        if (state = 0) { /* MENU */ }
        
        if (state = 1) {
            let key = Keyboard.keyPressed();
            do processInput(key);
            
            // âœ… FÃ­sica normalizada
            if ((frame / UPDATE_EVERY) * UPDATE_EVERY = frame) {
                do updatePhysics();
                let tick = tick + 1;
            }
            
            // âœ… Render parcial
            do renderFrame();
            
            if (DEBUG) { do showDebugInfo(); }
            
            // Transiciones
            if (ball.getY() > screenHeight) { let state = 2; }
        }
        
        if (state = 2) {
            do loseLifeTransition();    // âœ… Con Sys.wait(400)
            let state = 1;
        }
        
        // ... otros estados ...
        
        let frame = frame + 1;
        
        // âœ… FRAME LIMITER REAL
        do Sys.wait(FRAME_WAIT_MS);
    }
    return;
}

method void updatePhysics() {
    if (paused) { return; }
    
    do ball.move();                 // âœ… Solo se llama cada UPDATE_EVERY frames
    do checkWallCollisions();
    do checkPaddleCollision();
    do blockGrid.checkCollision(ball);
    
    return;
}

method void renderFrame() {
    // âœ… NO clearScreen() aquÃ­
    do drawHUD();                   // âœ… Solo HUD (barato)
    return;
}

method void initialDraw() {
    do Screen.clearScreen();        // âœ… Solo UNA VEZ por nivel
    do blockGrid.draw();
    do paddle.draw();
    do ball.draw();
    do drawHUD();
    return;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESUMEN DE MEJORAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
   1. FRAME LIMITER REAL
      - Antes: while(delay<50) â†’ depende del slider
      - DespuÃ©s: Sys.wait(2) â†’ independiente del slider

   2. FÃSICA NORMALIZADA
      - Antes: update() cada frame â†’ variable
      - DespuÃ©s: updatePhysics() cada 3 frames â†’ constante

   3. DIRTY RECTANGLES
      - Antes: Screen.clearScreen() cada frame â†’ parpadeo
      - DespuÃ©s: Solo borrar/redibujar lo que cambiÃ³ â†’ suave

   4. MÃQUINA DE ESTADOS
      - Antes: Flags booleanos confusos
      - DespuÃ©s: Estados claros con transiciones definidas

   5. WAITS APROPIADOS
      - Antes: Busy-loops sin Sys.wait
      - DespuÃ©s: Sys.wait() en todos los loops

   Resultado: Juego determinista y profesional ğŸ‰
*/
